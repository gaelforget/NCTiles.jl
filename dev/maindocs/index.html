<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · NCTiles</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NCTiles</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>User Guide</a><ul class="internal"><li><a class="tocitem" href="#Data-Structures-and-Functions"><span>Data Structures &amp; Functions</span></a></li><li><a class="tocitem" href="#Basic-Example"><span>Basic Example</span></a></li><li><a class="tocitem" href="#Other-Data-Structures"><span>Other Data Structures</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Use Examples</a></li><li><a class="tocitem" href="../API/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gaelforget/NCTiles.jl/blob/master/docs/src/maindocs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="User-Guide"><a class="docs-heading-anchor" href="#User-Guide">User Guide</a><a id="User-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#User-Guide" title="Permalink"></a></h1><p><code>NCTiles.jl</code> first goes through lazy operations, on data structure, as it obtains information about variables etc. The second phase calls <code>write</code> function to instantiate and write files. <em>Note:</em> some of the included functions are interfaces to <code>MITgcm</code> output.</p><p>Data structures:</p><ul><li><code>NCvar</code> contains information needed to write a NetCDF file which can include a list of filenames (see <code>BinData</code>) if the data is not loaded into memory.</li><li><code>NCData</code> contains a string (NetCDF file name) + metadata to read files.</li><li><code>BinData</code> is a container for one field.</li><li><code>TileData</code> contains a <code>MeshArray</code> or <code>BinData</code> struct in <code>vals</code>,   information about the tile layout in <code>tileinfo</code>, and metadata needed to   read/write tile data.</li></ul><p>As an example:</p><pre><code class="language-julia hljs">struct TileData{T}
    vals::T
    tileinfo::Dict
    tilesize::Tuple
    precision::Type
    numtiles::Int
end</code></pre><h2 id="Data-Structures-and-Functions"><a class="docs-heading-anchor" href="#Data-Structures-and-Functions">Data Structures &amp; Functions</a><a id="Data-Structures-and-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structures-and-Functions" title="Permalink"></a></h2><p>Higher-level APIs, which are practical for automated or distributed workflows which can be called upon e.g. as a model runs forward in time, are readily documented in the examples. Here we take a more detailed look at a basic one to document the underlying / core data structures and functionalities.</p><p>The core functionality of NCTiles comes from a series of data structures that contain the information needed write to NetCDF files. This includes the information and methods needed to read from source files. The data structure used for writing a variable is <code>NCvar</code>, which includes that variable&#39;s data and metadata. The data itself can be in memory and included directly in the <code>NCvar</code> struct, or can be described in another data structure (<code>NCData</code> / <code>BinData</code> / <code>TileData</code>) :</p><ul><li><code>BinData</code> for data in binary files</li><li><code>NCData</code> for data in NetCDF files</li><li><code>TileData</code> for e.g. tiled model output when subdomains is often written out in distributed fashion across file collections (see <a href="https://juliaclimate.github.io/MeshArrays.jl/dev">MeshArrays</a> for suitable Earth domain decomposition examples).</li></ul><h2 id="Basic-Example"><a class="docs-heading-anchor" href="#Basic-Example">Basic Example</a><a id="Basic-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Example" title="Permalink"></a></h2><p>Here we show how to write a metadata-rich <code>NetCDF</code> file from a series of binary data files, which represents output from a climate model (<code>MITgcm</code> output in this example). We try here to document the <code>metadata</code> specification in detail as one of the main goals of <code>NCTiles.jl</code> is to facilitate the production of metadata-rich data sets that are easily reuseable. </p><h3 id="Define-Dimensions"><a class="docs-heading-anchor" href="#Define-Dimensions">Define Dimensions</a><a id="Define-Dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Dimensions" title="Permalink"></a></h3><p>The first step for creating a NetCDF file is to define your dimensions. Each dimension is specified by an <code>NCvar</code>. Dimensions should be in an <code>Array</code> in the order corresponding to your variable data (if your data dimensions are lon x lat x time, dimensions should be in that order as well). In this example we have a regular half-degree lat-lon grid with 10 time steps (as in <code>ex_1.jl</code>). This is how we define the dimensions:</p><pre><code class="language-julia hljs">lon = -179.75:0.5:179.75
lat = -89.75:0.5:89.75
time = 1:10

dims = [NCvar(&quot;lon&quot;,&quot;degrees_east&quot;,size(lon),lon,Dict(&quot;long_name&quot; =&gt; &quot;longitude&quot;),NCDatasets),
        NCvar(&quot;lat&quot;,&quot;degrees_north&quot;,size(lat),lat,Dict(&quot;long_name&quot; =&gt; &quot;latitude&quot;),NCDatasets),
        NCvar(&quot;time&quot;,&quot;days since 1992-01-01&quot;,Inf,time,Dict((&quot;long_name&quot; =&gt; &quot;tim&quot;,&quot;standard_name&quot; =&gt; &quot;time&quot;)),NCDatasets)
        ]</code></pre><p>Let&#39;s go through the <code>NCvar</code> constructor. Here is the struct definition for reference:</p><pre><code class="language-julia hljs">struct NCvar
    name::String
    units::String
    dims
    values
    atts::Union{Dict,Nothing}
    backend::Module
end</code></pre><p>The first attribute, <code>name</code>, should be a <code>String</code> and is what you want to call the variable in the file. The second are the units, which should also be a <code>String</code>. We then specify the dimensions, <code>dims</code>. For Dimension variables <code>dims</code> should be of length 1 (calling <code>size</code> on your dimension values like above if sufficient). Next you specify the actual dimension values. For a Dimension variable, this must be a 1 dimensional array, like above. After the values you can specify any additional attributes that you want to add to the variable as a dictionary. The last attribute is the backend, which allows you to choose between <code>NCDatasets.jl</code> and <code>NetCDF.jl</code>. We have some support for <code>NetCDF.jl</code> and full support for <code>NCDatasets.jl</code>. Note that in creating these <code>NCvar</code> structs we do not do any CF Compliance checks, it is the user&#39;s responsibility to provide CF-compliant units.</p><h3 id="Define-the-Data-Source"><a class="docs-heading-anchor" href="#Define-the-Data-Source">Define the Data Source</a><a id="Define-the-Data-Source-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-Data-Source" title="Permalink"></a></h3><p>Once you&#39;ve created the dimensions for your NetCDF file you can create <code>NCvar</code> for your variable. Here we are going to create one pointing to data that is stored in multiple Binary files, one for each time step. The first step is to create this pointer to the data, which is the <code>BinData</code> struct. For example:</p><pre><code class="language-julia hljs">precision = Float32
datapath = &quot;data/binfiles/&quot;
fnames = joinpath.(Ref(datapath),
                    [&quot;Chl050.001.data&quot;,&quot;Chl050.002.data&quot;,&quot;Chl050.003.data&quot;,&quot;Chl050.004.data&quot;,&quot;Chl050.005.data&quot;,&quot;Chl050.006.data&quot;,&quot;Chl050.007.data&quot;,&quot;Chl050.008.data&quot;,&quot;Chl050.009.data&quot;,&quot;Chl050.010.data&quot;])
vardata = BinData(fnames,precision,(length(lon),length(lat)))
# or: vardata = BinData(fnames,precision,(length(lon),length(lat)),1)</code></pre><p>And for reference, the struct definition for <code>BinData</code>:</p><pre><code class="language-julia hljs">struct BinData # Pointer to data stored in binary files- contains info needed to read in
    fnames::Union{Array{String},String}
    precision::Type
    iosize::Tuple
    fldidx::Int
end</code></pre><p>In order to read data from a binary file, we need to know where the files are and their names, the precision that the data is written in, and the dimensions of the data. The first argument, <code>fnames</code>, should be a single file path <code>String</code> or an <code>Array</code> of file paths <code>String</code>s. The second should be the precision that the data is written in the file, here our data is <code>Float32</code>. Precision should be a <code>Type</code>. Finally we need to know the size of the data that we are reading from the file, this should be specified as a <code>Tuple</code>. If we have multiple variables written in the same file, we can additionally specify the index of that variable, say if it&#39;s the 10th variable in the file. In this example there is only one variable in the file, so we can specify 1 or leave it out and it will be assumed to be 1.</p><h3 id="Create-the-NCvar"><a class="docs-heading-anchor" href="#Create-the-NCvar">Create the NCvar</a><a id="Create-the-NCvar-1"></a><a class="docs-heading-anchor-permalink" href="#Create-the-NCvar" title="Permalink"></a></h3><p>Now we can create the NCvar for the variable we want to write to the file.</p><pre><code class="language-julia hljs">varname = &quot;Chl050&quot;
units = &quot;mg Chl&quot;
longname = &quot;Average chlorophyll concentration (top 50m)&quot;
myvar = NCvar(varname,units,dims,vardata,Dict(&quot;long_name&quot; =&gt; longname),NCDatasets)</code></pre><p>Creating the final <code>NCvar</code> for our variable is similar to creating a dimension <code>NCvar</code>. We specify the name we want to use in the file and the units. Here we use the <code>dims</code> array and the <code>vardata</code> struct we created above. We specify a <code>long_name</code> attribute, and finally indicate that we want to use <code>NCDatasets</code> in the backend.</p><h3 id="Writing-to-the-NetCDF-File"><a class="docs-heading-anchor" href="#Writing-to-the-NetCDF-File">Writing to the NetCDF File</a><a id="Writing-to-the-NetCDF-File-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-to-the-NetCDF-File" title="Permalink"></a></h3><p>Assuming you&#39;ve created the above structs as expected, executing the <code>write</code> function is as simple as:</p><pre><code class="language-julia hljs">README = &quot;A useful README that describes the data in the file.&quot;
attributes = Dict([&quot;_FillValue&quot;=&gt;NaN, &quot;missing_value&quot; =&gt; NaN])
write(myvar,&quot;data/mydata.nc&quot;,README=README,globalattribs=attributes)</code></pre><p>The <code>write</code> function requires at a minimum an <code>NCvar</code> and the output file path. It writes the <code>NCvar</code> to the file with default global attributes. Additionally you can specify a <code>README</code> and global attributes, by passing a <code>String</code> or Array of Strings to the <code>README</code> keyword argument or by providing a <code>Dict</code> to the <code>globalattribs</code> keyword argument, as shown above.</p><p>If you would like to write multiple variables to the same file, you can pass a <code>Dict{String,NCvar}</code> into the <code>write</code> function:</p><pre><code class="language-julia hljs">myvars = Dict([&quot;myvar1&quot; =&gt; myvar1,
                &quot;myvar2&quot; =&gt; myvar2])
write(myvar,&quot;data/mydata.nc&quot;)</code></pre><p>Where the keys of the <code>Dict</code> should match the <code>name</code> attributes of the <code>NCvar</code> struct values.</p><h2 id="Other-Data-Structures"><a class="docs-heading-anchor" href="#Other-Data-Structures">Other Data Structures</a><a id="Other-Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Data-Structures" title="Permalink"></a></h2><p>In the example above we wrote a NetCDF file with data sourced from Binary Files, specified by the <code>BinData</code> struct. We have a few other structs for different kinds of data:</p><ul><li><code>NCData</code>: for data sourced from a NetCDF file</li><li><code>TileData</code>: for data to be written into separate tile files</li></ul><h4 id="NCData"><a class="docs-heading-anchor" href="#NCData">NCData</a><a id="NCData-1"></a><a class="docs-heading-anchor-permalink" href="#NCData" title="Permalink"></a></h4><p><code>NCData</code> structs contain the necessary information to read data from a NetCDF file.</p><pre><code class="language-julia hljs">struct NCData
    fname::AbstractString
    varname::AbstractString
    backend::Module
    precision::Type
end</code></pre><p>For example, if you wanted to use the NetCDF file created before as a data source, you would use the <code>NCData</code> constructor:</p><pre><code class="language-julia hljs">myvardata = NCData(&quot;data/mydata.nc&quot;,&quot;Chl050&quot;,NCDatasets)</code></pre><p>Where the arguments are: file path; variable name; backend.</p><p>Alternatively, we provide the function <code>readncfile</code> which creates <code>NCvar</code>s containing the <code>NCData</code> structs for all the variables in the file:</p><pre><code class="language-julia hljs">ncvars,ncdims,fileatts = readncfile(&quot;data/mydata.nc&quot;)</code></pre><p>Here, the <code>ncvars</code> dictionary contains <code>NCvar</code>s of all the variables in the file. Each <code>NCvar</code> has <code>NCData</code> structs in the <code>values</code> attribute, which avoids reading in all the data from the file. In this case the <code>NCData</code> can be accessed as <code>myvardata = ncvars[&quot;Chl050&quot;].values</code>.</p><p>To re-write this exact file run:</p><pre><code class="language-julia hljs">write(ncvars,joinpath(&quot;data/mydata2.nc&quot;),globalattribs=fileatts)</code></pre><p>You can see this process demonstrated in <code>ex_2.jl</code>.</p><h3 id="TileData"><a class="docs-heading-anchor" href="#TileData">TileData</a><a id="TileData-1"></a><a class="docs-heading-anchor-permalink" href="#TileData" title="Permalink"></a></h3><p>The <code>TileData</code> struct is used to chunk up data and write to separate files. We do this using the <code>MeshArrays</code> package. This is demonstrated in more detail in <code>ex_4.jl</code>. First, specify your grid and read in the grid variables:</p><pre><code class="language-julia hljs">grid = GridSpec(&quot;LatLonCap&quot;,&quot;grids/GRID_LLC90/&quot;)
gridvars = GridLoad(grid)</code></pre><p>Where <code>GridSpec()</code> and <code>GridLoad()</code> are from the <code>MeshArrays</code> package (you can refer to the <code>MeshArrays</code> documentation for more information about these functions and grids).</p><p>The next step is to specify the tile, or chunk, size as a <code>tuple</code>. The data is chunked in the horizontal dimension, so tile sizes should be two dimensional <code>tuple</code>. If the data is three dimensional, say its full dimension is <code>NxMx10</code> and the tile size is <code>nxm</code>, the chunks will be <code>nxmx10</code>. Here we set the tile size to <code>90x90</code>:</p><pre><code class="language-julia hljs">tilesize = (90,90)</code></pre><p>When defining dimensions for <code>TileData</code> variables, the horizontal dimensions should be the size of the tiles, and their values integers <code>1:n</code> or <code>1:m</code> for an <code>nxm</code> tile:</p><pre><code class="language-julia hljs">time = 1:10
dep = gridvars[&quot;RC&quot;]
dims = [
    NCvar(&quot;i_c&quot;,&quot;1&quot;,tilesize[1],1:tilesize[1],Dict(&quot;long_name&quot; =&gt; &quot;Cartesian coordinate 1&quot;),NCDatasets),
    NCvar(&quot;j_c&quot;,&quot;1&quot;,tilesize[2],1:tilesize[2],Dict(&quot;long_name&quot; =&gt; &quot;Cartesian coordinate 2&quot;),NCDatasets),
    NCvar(&quot;dep_c&quot;,&quot;m&quot;,size(dep),dep,Dict(&quot;long_name&quot; =&gt; &quot;depth&quot;,&quot;standard_name&quot; =&gt; &quot;depth&quot;,&quot;positive&quot; =&gt; &quot;down&quot;),NCDatasets),
    NCvar(&quot;time&quot;,&quot;days since 1992-01-01&quot;,Inf,time,Dict((&quot;long_name&quot; =&gt; &quot;tim&quot;,&quot;standard_name&quot; =&gt; &quot;time&quot;)),NCDatasets)
]</code></pre><p>The latitude and longitude variables will be written to the file separately, their data specified by <code>TileData</code> structs:</p><pre><code class="language-julia hljs">tillat = TileData(gridvars[&quot;YC&quot;],tilesize,grid)
varlat = NCvar(&quot;lat&quot;,&quot;degrees_north&quot;,dims[1:2],tillat,Dict(&quot;long_name&quot; =&gt; &quot;latitude&quot;),NCDatasets)
tillon = TileData(gridvars[&quot;XC&quot;],tilesize,grid)
varlon = NCvar(&quot;lon&quot;,&quot;degrees_east&quot;,dims[1:2],tillon,Dict(&quot;long_name&quot; =&gt; &quot;longitude&quot;),NCDatasets)</code></pre><p>Since the data for latitude and longitude are held in memory (in the <code>gridvars</code> dictionary), we can specify it directly. At construction, the TileData struct will create the mapping for which indices of the latitude and longitude data should be put in each tile. When a file is written, <code>NCTiles</code> will use this mapping to extract the chunk for that file. The dimensions for the corresponding <code>NCvar</code>s should have the dimensions <code>dims[1:2]</code>, corresponding to <code>i_c</code> and <code>j_c</code>.</p><p>The variable we want to write is in a binary data file, so we can use a <code>BinData</code> struct in the <code>TileData</code> for our variable:</p><pre><code class="language-julia hljs">vardata = TileData(BinData(fnames,prec,iosize),
                    tilesize,
                    grid)
myvar = NCvar(varname,&quot;myunits&quot;,dims,vardata,Dict(),NCDatasets)</code></pre><p>The final step is to create the <code>NCvar</code>s and write them to the <code>NetCDF</code> files:</p><pre><code class="language-julia hljs">vars = Dict([varname =&gt; myvar,
                    &quot;lon&quot; =&gt; varlon,
                    &quot;lat&quot; =&gt; varlat
            ])

savenamebase = &quot;data/mytiledata&quot;
write(vars,savenamebase)</code></pre><p>The <code>write</code> function will create one file for each tile, using <code>savenamebase</code> as a prefix for the file path. It will append a zero-padded number to the end of the filename, along with the extension <code>.nc</code>. For this example we would have the files <code>data/mytiledata.0001.nc</code>, <code>data/mytiledata.0002.nc</code>, ..., <code>data/mytiledata.0013.nc</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/">Use Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Saturday 7 August 2021 17:28">Saturday 7 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
